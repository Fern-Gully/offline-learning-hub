<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ChromaShift</title>
    <style>
        :root {
            --color-1: #ff3860; /* Red */
            --color-2: #38c1ff; /* Blue */
            --color-3: #ffdd57; /* Yellow */
            --color-4: #48c774; /* Green */
            --color-5: #b86bff; /* Purple */
            --color-6: #ff7f50; /* Orange */
            --bg-color: #1a1a2e;
            --text-color: #e0e0fc;
            --glow-filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.7));
            font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', sans-serif;
        }

        /* --- Basic Setup & Background --- */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        #game-container {
            position: relative;
            max-width: 600px;
            max-height: 800px;
            width: 100%;
            height: 100%;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            -webkit-tap-highlight-color: transparent; /* Disable tap highlight on mobile */
        }
        #background-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        #game-svg {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
        }
        #particle-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 3;
            pointer-events: none; /* Let clicks pass through */
        }

        /* --- UI Elements --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 4;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        .ui-text {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 20px;
            filter: var(--glow-filter);
        }
        #score { text-align: left; align-self: flex-start; }
        #high-score { text-align: right; align-self: flex-end; }
        #level-display {
            font-size: 1.5rem;
            font-weight: 500;
            opacity: 0.8;
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* --- Game Over / Start Menu --- */
        #menu-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 5;
            background-color: rgba(26, 26, 46, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.5s ease;
        }
        .menu-hidden {
            opacity: 0;
            pointer-events: none;
        }
        #menu-title {
            font-size: 5rem;
            font-weight: 800;
            filter: var(--glow-filter);
            margin-bottom: 20px;
        }
        #menu-subtitle {
            font-size: 1.5rem;
            margin-bottom: 40px;
        }
        #play-button {
            font-size: 2rem;
            font-weight: 700;
            padding: 15px 40px;
            border: 3px solid var(--text-color);
            border-radius: 50px;
            cursor: pointer;
            background-color: transparent;
            color: var(--text-color);
            transition: all 0.2s ease;
            filter: var(--glow-filter);
            pointer-events: all;
        }
        #play-button:hover, #play-button:focus {
            background-color: var(--text-color);
            color: var(--bg-color);
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--text-color);
        }
        #instructions {
            margin-top: 50px;
            font-size: 1.1rem;
            line-height: 1.6;
        }

        /* --- Animations --- */
        .game-over-shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="background-canvas"></canvas>
        <svg id="game-svg" xmlns="http://www.w3.org/2000/svg"></svg>
        <canvas id="particle-canvas"></canvas>

        <div id="ui-layer">
            <div id="score" class="ui-text">0</div>
            <div id="level-display">Level 1</div>
            <div id="high-score" class="ui-text">HS: 0</div>
        </div>

        <div id="menu-overlay">
            <div id="menu-title">ChromaShift</div>
            <div id="menu-subtitle">Match the colors. Test your reflexes.</div>
            <button id="play-button">Play</button>
            <div id="instructions">
                <b>Desktop:</b> Use ← → Arrow Keys to rotate.<br>
                <b>Mobile:</b> Tap left/right side of the screen.
            </div>
        </div>
    </div>

    <script>
    // --- Polyfill for requestAnimationFrame ---
    window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) { window.setTimeout(callback, 1000 / 60); };

    // --- DOM Elements ---
    const gameContainer = document.getElementById('game-container');
    const svg = document.getElementById('game-svg');
    const particleCanvas = document.getElementById('particle-canvas');
    const pCtx = particleCanvas.getContext('2d');
    const backgroundCanvas = document.getElementById('background-canvas');
    const bgCtx = backgroundCanvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('high-score');
    const levelDisplayEl = document.getElementById('level-display');
    const menuOverlay = document.getElementById('menu-overlay');
    const playButton = document.getElementById('play-button');
    const menuSubtitle = document.getElementById('menu-subtitle');

    // --- Game Configuration ---
    const SVG_NS = "http://www.w3.org/2000/svg";
    const COLORS = ['--color-1', '--color-2', '--color-3', '--color-4', '--color-5', '--color-6'];
    const getCssColor = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

    let resolvedColors = COLORS.map(getCssColor);

    // --- Game State ---
    let state = {
        score: 0,
        highScore: 0,
        level: 1,
        isGameOver: true,
        centerHex: null,
        projectiles: [],
        particles: [],
        lastTime: 0,
        gameTime: 0,
        nextProjectileTime: 0,
        keys: {},
        currentRotation: 0,
        targetRotation: 0,
    };

    // --- Game Dimensions ---
    let view = { width: 0, height: 0, centerX: 0, centerY: 0, hexRadius: 0 };

    // --- Web Audio API for Sound ---
    let audioContext;
    const initAudio = () => {
        if (!audioContext) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.error("Web Audio API is not supported in this browser");
            }
        }
    };
    
    const playSound = (type) => {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        if (type === 'match') {
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.2);
        } else if (type === 'gameOver') {
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(55, audioContext.currentTime + 0.5);
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.5);
        } else if (type === 'levelUp') {
            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.3);
            setTimeout(() => {
                const osc2 = audioContext.createOscillator();
                const gain2 = audioContext.createGain();
                osc2.connect(gain2);
                gain2.connect(audioContext.destination);
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(659.25, audioContext.currentTime); // E5
                gain2.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain2.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.3);
                osc2.start();
                osc2.stop(audioContext.currentTime + 0.3);
            }, 100);
        }

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.5);
    };


    // --- Game Logic ---
    const levelConfig = {
        1: { speed: 1, interval: 2000, colors: 3, name: "The Basics" },
        2: { speed: 1.2, interval: 1800, colors: 3, name: "Warming Up" },
        3: { speed: 1.5, interval: 1600, colors: 4, name: "New Color" },
        4: { speed: 1.8, interval: 1500, colors: 4, name: "Faster!" },
        5: { speed: 2, interval: 1400, colors: 5, name: "Think Quick" },
        6: { speed: 2.2, interval: 1300, colors: 5, name: "In The Zone" },
        7: { speed: 2.5, interval: 1200, colors: 6, name: "Full Spectrum" },
        8: { speed: 2.8, interval: 1100, colors: 6, name: "Pro Level" },
        9: { speed: 3.1, interval: 1000, colors: 6, name: "Reflex Master" },
        10: { speed: 3.5, interval: 900, colors: 6, name: "Insanity" }
    };
    
    const getConfig = (level) => levelConfig[Math.min(level, Object.keys(levelConfig).length)];

    const resetGame = () => {
        state.score = 0;
        state.level = 1;
        state.isGameOver = false;
        state.projectiles.forEach(p => svg.removeChild(p.el));
        state.projectiles = [];
        state.particles = [];
        state.gameTime = 0;
        state.nextProjectileTime = 2000;
        state.currentRotation = 0;
        state.targetRotation = 0;
        
        updateUI();
        createCenterHex();
    };

    const startGame = () => {
        initAudio(); // Initialize audio on user interaction
        resetGame();
        menuOverlay.classList.add('menu-hidden');
        state.lastTime = performance.now();
        gameLoop();
    };

    const gameOver = () => {
        playSound('gameOver');
        state.isGameOver = true;
        if (state.score > state.highScore) {
            state.highScore = state.score;
            localStorage.setItem('chromaShiftHighScore', state.highScore);
        }
        updateUI();
        menuSubtitle.textContent = `Your Score: ${state.score}. High Score: ${state.highScore}`;
        playButton.textContent = "Retry";
        menuOverlay.classList.remove('menu-hidden');
        gameContainer.classList.add('game-over-shake');
        setTimeout(() => gameContainer.classList.remove('game-over-shake'), 500);
    };

    // --- Object Creation ---
    const createSVGElem = (tag, attrs) => {
        const el = document.createElementNS(SVG_NS, tag);
        for (let k in attrs) {
            el.setAttribute(k, attrs[k]);
        }
        return el;
    };

    const createCenterHex = () => {
        if (state.centerHex) svg.removeChild(state.centerHex.el);
        
        const numSides = getConfig(state.level).colors;
        const group = createSVGElem('g', { id: 'center-hex' });
        
        const points = [];
        for (let i = 0; i < numSides; i++) {
            const angle_deg = 360 / numSides * i - (90 - 180/numSides);
            const angle_rad = Math.PI / 180 * angle_deg;
            points.push({
                x: view.centerX + view.hexRadius * Math.cos(angle_rad),
                y: view.centerY + view.hexRadius * Math.sin(angle_rad)
            });
        }

        for (let i = 0; i < numSides; i++) {
            const p1 = points[i];
            const p2 = points[(i + 1) % numSides];
            const path = `M ${view.centerX},${view.centerY} L ${p1.x},${p1.y} L ${p2.x},${p2.y} Z`;
            const segment = createSVGElem('path', {
                d: path,
                fill: resolvedColors[i],
            });
            group.appendChild(segment);
        }
        svg.appendChild(group);
        state.centerHex = { el: group, numSides };
    };

    const createProjectile = () => {
        const config = getConfig(state.level);
        const colorIndex = Math.floor(Math.random() * config.colors);
        const angle_deg = Math.random() * 360;
        const angle_rad = Math.PI / 180 * angle_deg;

        const spawnDist = Math.max(view.width, view.height) / 2 + 50;
        const x = view.centerX + spawnDist * Math.cos(angle_rad);
        const y = view.centerY + spawnDist * Math.sin(angle_rad);

        const speed = view.hexRadius * 0.01 * config.speed;
        const dx = (view.centerX - x) / (spawnDist / speed);
        const dy = (view.centerY - y) / (spawnDist / speed);
        
        const size = view.hexRadius * 0.2;
        const triangle = createSVGElem('polygon', {
            points: `0,${-size} ${size},${size} ${-size},${size}`,
            fill: resolvedColors[colorIndex],
            transform: `translate(${x}, ${y}) rotate(${angle_deg + 90})`,
            filter: 'url(#glow)',
        });

        svg.appendChild(triangle);

        state.projectiles.push({
            el: triangle,
            x, y, dx, dy,
            colorIndex,
            rotation: angle_deg + 90,
        });
    };
    
    const createParticles = (x, y, color) => {
        const count = 20;
        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5 + 2;
            state.particles.push({
                x, y,
                dx: Math.cos(angle) * speed,
                dy: Math.sin(angle) * speed,
                life: 1,
                color,
            });
        }
    };


    // --- Update and Draw ---
    const update = (dt) => {
        // Update game time and spawn projectiles
        state.gameTime += dt;
        if (state.gameTime >= state.nextProjectileTime) {
            createProjectile();
            state.nextProjectileTime = state.gameTime + getConfig(state.level).interval / (1 + state.level * 0.1);
        }

        // Update hex rotation (smoothly)
        const rotationDiff = state.targetRotation - state.currentRotation;
        state.currentRotation += rotationDiff * 0.2;
        
        // Update projectiles
        state.projectiles.forEach((p, index) => {
            p.x += p.dx;
            p.y += p.dy;
            
            const dist = Math.sqrt(Math.pow(p.x - view.centerX, 2) + Math.pow(p.y - view.centerY, 2));
            if(dist < view.hexRadius) {
                // Collision check
                const numSides = state.centerHex.numSides;
                const anglePerSegment = 360 / numSides;
                
                // Normalize current rotation to be between 0 and 360
                let hexRotation = (state.currentRotation % 360 + 360) % 360;

                const projectileAngle = (Math.atan2(p.y - view.centerY, p.x - view.centerX) * 180 / Math.PI + 360) % 360;
                
                let correctedAngle = (projectileAngle - hexRotation + 360 + anglePerSegment / 2) % 360;
                let segmentIndex = Math.floor(correctedAngle / anglePerSegment);
                
                if(segmentIndex === p.colorIndex) {
                    // Correct match
                    playSound('match');
                    state.score++;
                    checkLevelUp();
                    createParticles(p.x, p.y, resolvedColors[p.colorIndex]);
                    svg.removeChild(p.el);
                    state.projectiles.splice(index, 1);
                } else {
                    // Incorrect match
                    gameOver();
                }
            }
        });
        
        // Update particles
        state.particles.forEach((p, index) => {
            p.x += p.dx;
            p.y += p.dy;
            p.life -= 0.02;
            if(p.life <= 0) {
                state.particles.splice(index, 1);
            }
        });
    };

    const draw = () => {
        // Draw hex
        if (state.centerHex) {
            state.centerHex.el.setAttribute('transform', `rotate(${state.currentRotation}, ${view.centerX}, ${view.centerY})`);
        }
        
        // Draw projectiles
        state.projectiles.forEach(p => {
            p.el.setAttribute('transform', `translate(${p.x}, ${p.y}) rotate(${p.rotation})`);
        });
        
        // Draw particles on canvas
        pCtx.clearRect(0, 0, view.width, view.height);
        state.particles.forEach(p => {
            pCtx.fillStyle = p.color;
            pCtx.globalAlpha = p.life;
            pCtx.beginPath();
            pCtx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            pCtx.fill();
        });
        pCtx.globalAlpha = 1;
    };
    
    const drawBackground = () => {
        const gradient = bgCtx.createRadialGradient(
            view.centerX, view.centerY, 0,
            view.centerX, view.centerY, Math.max(view.width, view.height)
        );
        const startColor = resolvedColors[(state.level - 1) % resolvedColors.length];
        gradient.addColorStop(0, startColor + '33'); // Add alpha
        gradient.addColorStop(1, getCssColor('--bg-color'));
        bgCtx.fillStyle = gradient;
        bgCtx.fillRect(0, 0, view.width, view.height);
    };

    const gameLoop = (timestamp) => {
        if (state.isGameOver) return;
        
        const dt = timestamp - state.lastTime;
        state.lastTime = timestamp;

        update(dt);
        draw();
        
        requestAnimationFrame(gameLoop);
    };

    // --- UI & Event Handling ---
    const updateUI = () => {
        scoreEl.textContent = state.score;
        highScoreEl.textContent = `HS: ${state.highScore}`;
        levelDisplayEl.textContent = `Level ${state.level}: ${getConfig(state.level).name}`;
    };

    const checkLevelUp = () => {
        const scoreForNextLevel = state.level * 5 + 5;
        if (state.score >= scoreForNextLevel) {
            state.level++;
            playSound('levelUp');
            createCenterHex();
            drawBackground();
            updateUI();
        }
    };
    
    const handleResize = () => {
        const { width, height } = gameContainer.getBoundingClientRect();
        view.width = width;
        view.height = height;
        view.centerX = width / 2;
        view.centerY = height / 2;
        view.hexRadius = Math.min(width, height) * 0.2;

        particleCanvas.width = width;
        particleCanvas.height = height;
        backgroundCanvas.width = width;
        backgroundCanvas.height = height;
        
        // Add SVG filter for glow effect
        svg.innerHTML = `
            <defs>
                <filter id="glow">
                    <feGaussianBlur stdDeviation="3.5" result="coloredBlur"/>
                    <feMerge>
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>
        `;
        
        if (!state.isGameOver) {
            createCenterHex();
        }
        drawBackground();
    };

    const handleKeyDown = (e) => {
        if(state.isGameOver) return;
        const sides = state.centerHex.numSides;
        if (e.key === 'ArrowLeft') {
            state.targetRotation -= 360 / sides;
        } else if (e.key === 'ArrowRight') {
            state.targetRotation += 360 / sides;
        }
    };

    const handleTap = (e) => {
        if(state.isGameOver) return;
        e.preventDefault();
        const sides = state.centerHex.numSides;
        const tapX = e.touches ? e.touches[0].clientX : e.clientX;
        if(tapX < view.width / 2) {
             state.targetRotation -= 360 / sides;
        } else {
             state.targetRotation += 360 / sides;
        }
        initAudio(); // Also init audio on first tap
    };
    
    // --- Initialization ---
    const init = () => {
        window.addEventListener('resize', handleResize);
        window.addEventListener('keydown', handleKeyDown);
        gameContainer.addEventListener('mousedown', handleTap);
        gameContainer.addEventListener('touchstart', handleTap);
        playButton.addEventListener('click', startGame);

        state.highScore = localStorage.getItem('chromaShiftHighScore') || 0;
        updateUI();
        handleResize();
    };

    init();

    </script>
</body>
</html>
