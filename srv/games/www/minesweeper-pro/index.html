<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Minesweeper Pro (Offline)</title>
<style>
  :root{
    --bg:#0a0f22; --bg2:#0e1533; --card:#12182a; --stroke:#1e2544;
    --accent:#3b82f6; --accent2:#8b5cf6; --muted:#9aa4b2; --fg:#e6e9ef;
    --good:#22c55e; --warn:#f59e0b; --bad:#ef4444; --glass:rgba(255,255,255,.06);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;color:var(--fg);font:16px/1.6 system-ui,Segoe UI,Helvetica,Arial,sans-serif;
    background:
      radial-gradient(1200px 600px at 10% -10%, rgba(59,130,246,.18), transparent 60%),
      radial-gradient(1000px 600px at 110% 20%, rgba(139,92,246,.16), transparent 60%),
      linear-gradient(180deg, var(--bg), var(--bg2));
    background-attachment: fixed;
  }
  header{
    padding:1.1rem 1rem;border-bottom:1px solid var(--stroke);
    text-align:center;font-weight:800;letter-spacing:.02em;
    position:sticky;top:0;backdrop-filter:saturate(140%) blur(6px);
    background:
      linear-gradient(to right, rgba(16,22,38,.65), rgba(16,22,38,.35)),
      radial-gradient(60% 120% at 50% -20%, rgba(59,130,246,.18), transparent 60%);
    z-index:10;
  }
  .wrap{max-width:1100px;margin:0 auto;padding:1rem 1.25rem;display:grid;gap:1rem;grid-template-columns:320px 1fr}
  @media (max-width:980px){ .wrap{grid-template-columns:1fr} }
  .panel{
    background:linear-gradient(180deg, rgba(20,26,42,.96), rgba(20,26,42,.85));
    border:1px solid var(--stroke); border-radius:16px; padding:1rem;
    box-shadow:0 10px 24px rgba(0,0,0,.32);
  }
  .toolbar{display:grid;gap:.6rem}
  .row{display:flex;gap:.6rem;flex-wrap:wrap;align-items:center}
  button, select, input[type="number"]{
    background:transparent;color:var(--fg);border:1px solid var(--accent);
    border-radius:10px;padding:.45rem .7rem;font-weight:700;letter-spacing:.02em;
  }
  button{cursor:pointer;transition:.15s}
  button:hover{background:rgba(59,130,246,.12)}
  .stat{
    padding:.35rem .6rem;border:1px solid var(--stroke);border-radius:8px;background:var(--glass);
    font-variant-numeric:tabular-nums; font-weight:800;
  }
  .muted{color:var(--muted)}
  .grid{
    user-select:none;touch-action:none;
    display:grid; gap:6px; padding:10px; background:var(--glass); border:1px solid var(--stroke);
    border-radius:14px;
  }
  .cell{
    width:34px;height:34px;border-radius:10px; display:flex;align-items:center;justify-content:center;
    font-weight:900; letter-spacing:.02em; position:relative;
    background:linear-gradient(160deg, rgba(14,20,40,.92), rgba(14,20,40,.78));
    border:1px solid rgba(255,255,255,.05);
    box-shadow: inset 0 4px 6px rgba(0,0,0,.25), 0 2px 4px rgba(0,0,0,.25);
    transition:transform .06s ease, background .12s ease, box-shadow .12s ease;
  }
  .cell:active{ transform:translateY(1px) }
  .cell.revealed{
    background:linear-gradient(160deg, rgba(24,30,50,.92), rgba(24,30,50,.8));
    box-shadow: inset 0 1px 2px rgba(0,0,0,.35);
  }
  .cell.flag::after{
    content:"‚öë"; position:absolute; font-size:18px; color:var(--accent2);
    filter:drop-shadow(0 0 4px rgba(139,92,246,.6));
  }
  .cell.mine.revealed::after{ content:"‚úπ"; color:var(--bad); font-size:18px; filter:drop-shadow(0 0 4px rgba(239,68,68,.7)); }
  .n1{color:#60a5fa}.n2{color:#34d399}.n3{color:#f87171}.n4{color:#a78bfa}
  .n5{color:#f59e0b}.n6{color:#10b981}.n7{color:#f472b6}.n8{color:#cbd5e1}
  .topbar{display:flex;gap:.6rem;align-items:center;justify-content:space-between;margin-bottom:.4rem}
  .topbar .stats{display:flex;gap:.5rem;flex-wrap:wrap}
  .best{font-size:.9rem}
  .label{font-size:.9rem;color:var(--muted)}
  .gridwrap{overflow:auto}
  .win{color:var(--good)} .lose{color:var(--bad)}
  .note{font-size:.9rem;color:var(--muted)}
</style>
</head>
<body>
  <header>üí£ Minesweeper Pro</header>

  <div class="wrap">
    <div class="panel">
      <div class="toolbar">
        <div class="row topbar">
          <div class="stats">
            <span class="stat">‚è± <b id="time">000</b>s</span>
            <span class="stat">üí£ <b id="minesLeft">000</b></span>
            <span class="stat">Seed <b id="seedLabel">‚Äî</b></span>
          </div>
          <div class="row">
            <button id="newGame">New Game</button>
            <button id="restart">Restart</button>
          </div>
        </div>

        <div class="row">
          <button data-preset="beg">Beginner</button>
          <button data-preset="int">Intermediate</button>
          <button data-preset="exp">Expert</button>
        </div>

        <div class="row">
          <span class="label">Custom:</span>
          <label>Rows <input id="rows" type="number" min="5" max="40" value="9" style="width:70px"/></label>
          <label>Cols <input id="cols" type="number" min="5" max="60" value="9" style="width:70px"/></label>
          <label>Mines <input id="mines" type="number" min="5" max="999" value="10" style="width:80px"/></label>
          <button id="apply">Apply</button>
        </div>

        <div class="row">
          <span class="label">Right-click = Flag ¬∑ Long-press on touch = Flag ¬∑ Middle-click (or chord) = open neighbors</span>
        </div>

        <div class="row best">
          <span class="label">Best (B/I/E):</span>
          <span id="bestBeg">‚Äî</span> /
          <span id="bestInt">‚Äî</span> /
          <span id="bestExp">‚Äî</span>
        </div>

        <div class="row">
          <span class="label">Shareable seed:</span>
          <input id="seedInput" placeholder="optional seed" style="flex:1; min-width:120px"/>
        </div>
      </div>
    </div>

    <div class="panel gridwrap">
      <div id="grid" class="grid" aria-label="Minesweeper grid"></div>
      <div class="note" id="status" style="margin-top:.6rem">Good luck!</div>
    </div>
  </div>

<script>
(() => {
  // ---------- Utilities: RNG ----------
  function xmur3(str){ let h=1779033703^str.length; for(let i=0;i<str.length;i++){ h=Math.imul(h^str.charCodeAt(i),3432918353); h=h<<13|h>>>19; } return ()=>{ h=Math.imul(h^ (h>>>16), 2246822507); h=Math.imul(h^ (h>>>13), 3266489909); return (h^=h>>>16)>>>0; } }
  function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ (t >>> 15), t | 1); t ^= t + Math.imul(t ^ (t >>> 7), t | 61); return ((t ^ (t >>> 14)) >>> 0) / 4294967296; } }

  // ---------- State ----------
  const url = new URL(location.href);
  const seedParam = url.searchParams.get("seed");
  let seed = seedParam || Math.floor(Math.random()*1e9).toString();
  let rand = mulberry32(xmur3(seed)());

  const gridEl = document.getElementById('grid');
  const timeEl = document.getElementById('time');
  const minesLeftEl = document.getElementById('minesLeft');
  const seedLabelEl = document.getElementById('seedLabel');
  const statusEl = document.getElementById('status');
  const seedInput = document.getElementById('seedInput');

  // size/settings
  const presets = {
    beg: {r:9, c:9, m:10},
    int: {r:16, c:16, m:40},
    exp: {r:16, c:30, m:99},
  };
  let rows=9, cols=9, mines=10;

  // gameplay
  let board = []; // per cell: {mine, r, c, adj, revealed, flag}
  let started=false, over=false, timer=null, t=0, flags=0, revealedCount=0;

  // ---------- Best times ----------
  const bestBegEl = document.getElementById('bestBeg');
  const bestIntEl = document.getElementById('bestInt');
  const bestExpEl = document.getElementById('bestExp');
  function fmtS(n){ return n ? `${n}s` : '‚Äî'; }
  function loadBests(){
    bestBegEl.textContent = fmtS(+localStorage.getItem('ms_best_beg')||0);
    bestIntEl.textContent = fmtS(+localStorage.getItem('ms_best_int')||0);
    bestExpEl.textContent = fmtS(+localStorage.getItem('ms_best_exp')||0);
  }
  function maybeRecordBest(){
    const key = (rows===9&&cols===9&&mines===10) ? 'ms_best_beg' :
                (rows===16&&cols===16&&mines===40) ? 'ms_best_int' :
                (rows===16&&cols===30&&mines===99) ? 'ms_best_exp' : null;
    if(!key) return;
    const prev = +localStorage.getItem(key) || 0;
    if(prev===0 || t<prev){ localStorage.setItem(key, String(t)); loadBests(); }
  }

  // ---------- Build board ----------
  function resetTimer(){ clearInterval(timer); t=0; timeEl.textContent = '000'; }
  function startTimer(){ if(timer) return; timer=setInterval(()=>{ t++; timeEl.textContent=String(t).padStart(3,'0');},1000); }
  function stopTimer(){ clearInterval(timer); timer=null; }

  function idx(r,c){ return r*cols+c; }
  function neighbors(r,c){
    const out=[];
    for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
      if(!dr && !dc) continue;
      const rr=r+dr, cc=c+dc;
      if(rr>=0 && cc>=0 && rr<rows && cc<cols) out.push([rr,cc]);
    }
    return out;
  }

  function newBoard(){
    over=false; started=false; flags=0; revealedCount=0;
    resetTimer();
    seedLabelEl.textContent = seed;
    seedInput.value = seed;

    // CSS grid sizing
    const cellSize = Math.max(26, Math.min(42, 34)); // clamp if you like
    gridEl.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;

    // init cells
    board = Array.from({length:rows*cols}, (_,i)=>({
      r: (i/cols)|0, c: i%cols, mine:false, adj:0, revealed:false, flag:false
    }));

    // place mines using shuffle of indices
    const total = rows*cols;
    const indices = Array.from({length:total}, (_,i)=>i);
    for(let i=total-1;i>0;i--){
      const j = (rand()* (i+1))|0;
      [indices[i], indices[j]] = [indices[j], indices[i]];
    }
    for(let i=0;i<mines;i++){
      board[indices[i]].mine = true;
    }

    // compute adjacency
    for(const cell of board){
      if(cell.mine){ cell.adj=0; continue; }
      let count=0;
      for(const [rr,cc] of neighbors(cell.r, cell.c)){
        if(board[idx(rr,cc)].mine) count++;
      }
      cell.adj = count;
    }

    minesLeftEl.textContent = String(mines - flags).padStart(3,'0');
    render();
    statusEl.textContent = 'Good luck!';
  }

  function render(){
    gridEl.innerHTML='';
    gridEl.className='grid';
    for(const cell of board){
      const d = document.createElement('div');
      d.className = 'cell';
      d.dataset.r = cell.r; d.dataset.c = cell.c;

      if(cell.revealed){
        d.classList.add('revealed');
        if(cell.mine){ d.classList.add('mine'); }
        else if(cell.adj>0){
          d.textContent = cell.adj;
          d.classList.add('n'+cell.adj);
        }
      }else{
        if(cell.flag) d.classList.add('flag');
      }
      gridEl.appendChild(d);
    }
  }

  // ensure first click never hits a mine (classic behavior)
  function ensureSafeFirstClick(r,c){
    const first = board[idx(r,c)];
    if(!first.mine) return;
    // swap this mine with a non-mine elsewhere
    for(let i=0;i<board.length;i++){
      if(!board[i].mine && (board[i].r!==r || board[i].c!==c)){
        board[i].mine=true; first.mine=false;
        // recompute adj for neighbors around both cells
        const recalc = new Set();
        neighbors(r,c).forEach(([rr,cc])=>recalc.add(idx(rr,cc)));
        neighbors(board[i].r, board[i].c).forEach(([rr,cc])=>recalc.add(idx(rr,cc)));
        recalc.forEach(id=>{
          const cell=board[id];
          if(cell.mine){ cell.adj=0; return;}
          let count=0; neighbors(cell.r,cell.c).forEach(([rr,cc])=>{ if(board[idx(rr,cc)].mine) count++; });
          cell.adj=count;
        });
        break;
      }
    }
  }

  // flood reveal (BFS)
  function flood(r,c){
    const q=[[r,c]]; const seen=new Set();
    while(q.length){
      const [rr,cc]=q.shift(); const id=idx(rr,cc);
      if(seen.has(id)) continue; seen.add(id);
      const cell = board[id];
      if(cell.revealed || cell.flag) continue;
      cell.revealed=true; revealedCount++;
      if(!cell.mine && cell.adj===0){
        neighbors(rr,cc).forEach(([nr,nc])=>q.push([nr,nc]));
      }
    }
  }

  function reveal(r,c){
    if(over) return;
    const cell = board[idx(r,c)];
    if(cell.flag || cell.revealed) return;

    if(!started){ started=true; ensureSafeFirstClick(r,c); startTimer(); }

    if(cell.mine){
      cell.revealed=true; over=true; stopTimer();
      // reveal all mines
      for(const m of board){ if(m.mine) m.revealed=true; }
      render();
      statusEl.innerHTML = `<span class="lose">Boom!</span> Seed ${seed}. New game?`;
      return;
    }

    if(cell.adj===0) flood(r,c); else { cell.revealed=true; revealedCount++; }
    checkWin();
    render();
  }

  function toggleFlag(r,c){
    if(over) return;
    const cell = board[idx(r,c)];
    if(cell.revealed) return;
    cell.flag = !cell.flag;
    flags += cell.flag?1:-1;
    minesLeftEl.textContent = String(mines - flags).padStart(3,'0');
    render();
  }

  // chord: open neighbors when flags == adj
  function chord(r,c){
    if(over) return;
    const cell = board[idx(r,c)];
    if(!cell.revealed || cell.adj===0) return;
    let flagCount=0; const neigh = neighbors(r,c);
    for(const [rr,cc] of neigh){ if(board[idx(rr,cc)].flag) flagCount++; }
    if(flagCount !== cell.adj) return;
    for(const [rr,cc] of neigh){
      const ncell = board[idx(rr,cc)];
      if(!ncell.revealed && !ncell.flag){
        reveal(rr,cc);
        if(over) return;
      }
    }
  }

  function checkWin(){
    if(over) return;
    const safe = rows*cols - mines;
    if(revealedCount >= safe){
      over=true; stopTimer();
      statusEl.innerHTML = `<span class="win">Cleared!</span> Time ${t}s ¬∑ Seed ${seed}`;
      maybeRecordBest();
    }
  }

  // ---------- Input handlers ----------
  function getRC(target){
    const el = target.closest('.cell');
    if(!el || !gridEl.contains(el)) return null;
    return [ +el.dataset.r, +el.dataset.c ];
  }

  gridEl.addEventListener('contextmenu', e=>e.preventDefault());

  gridEl.addEventListener('pointerdown', (e)=>{
    if(over) return;
    const rc = getRC(e.target); if(!rc) return;
    const [r,c]=rc;

    // detect middle click (aux) for chord
    if(e.button===1){ chord(r,c); return; }

    // long-press to flag on touch
    let longPressTimer = null;
    const startX=e.clientX, startY=e.clientY;
    const moveThresh=8;

    const clearLP=()=>{
      if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer=null; }
      window.removeEventListener('pointermove',onMove);
      window.removeEventListener('pointerup',onUp);
      window.removeEventListener('pointercancel',onUp);
    };

    const onMove=(ev)=>{
      if(!longPressTimer) return;
      if(Math.hypot(ev.clientX-startX, ev.clientY-startY)>moveThresh){
        clearLP();
      }
    };

    const onUp=(ev)=>{
      if(longPressTimer){
        // short tap/click
        clearLP();
        if(ev.button===2){ toggleFlag(r,c); return; } // right-click fallback
        // left click behavior
        reveal(r,c);
      }
    };

    window.addEventListener('pointermove', onMove, {passive:true});
    window.addEventListener('pointerup', onUp, {passive:true});
    window.addEventListener('pointercancel', onUp, {passive:true});

    if(e.pointerType==='touch'){
      longPressTimer = setTimeout(()=>{ toggleFlag(r,c); clearLP(); }, 500);
    } else {
      // mouse
      if(e.button===2){ toggleFlag(r,c); clearLP(); return; } // right click
      if(e.button===0){ reveal(r,c); clearLP(); return; }    // left click
    }
  });

  // double click to chord (desktop)
  gridEl.addEventListener('dblclick', (e)=>{
    const rc = getRC(e.target); if(!rc) return;
    chord(rc[0], rc[1]);
  });

  // keyboard support: arrows to move, space reveal, f flag, enter chord
  let kbR=0, kbC=0;
  document.addEventListener('keydown', (e)=>{
    if(over) return;
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','f','F',' ','Enter'].includes(e.key)) e.preventDefault();
    if(e.key==='ArrowUp') kbR = Math.max(0, kbR-1);
    if(e.key==='ArrowDown') kbR = Math.min(rows-1, kbR+1);
    if(e.key==='ArrowLeft') kbC = Math.max(0, kbC-1);
    if(e.key==='ArrowRight') kbC = Math.min(cols-1, kbC+1);
    if(e.key===' ') reveal(kbR,kbC);
    if(e.key==='f' || e.key==='F') toggleFlag(kbR,kbC);
    if(e.key==='Enter') chord(kbR,kbC);
    highlightKB();
  });
  function highlightKB(){
    document.querySelectorAll('.cell.kb').forEach(el=>el.classList.remove('kb'));
    const el = gridEl.querySelector(`.cell[data-r="${kbR}"][data-c="${kbC}"]`);
    if(el) el.classList.add('kb');
  }

  // ---------- Controls ----------
  function applyPreset(p){
    rows=presets[p].r; cols=presets[p].c; mines=presets[p].m;
    seed = seedParam || Math.floor(Math.random()*1e9).toString();
    rand = mulberry32(xmur3(seed)());
    newBoard(); highlightKB();
  }
  document.querySelectorAll('button[data-preset]').forEach(btn=>{
    btn.addEventListener('click', ()=>applyPreset(btn.dataset.preset));
  });

  document.getElementById('apply').onclick = ()=>{
    const r = +document.getElementById('rows').value|0;
    const c = +document.getElementById('cols').value|0;
    const m = +document.getElementById('mines').value|0;
    if(r<5||c<5||m<1||(m>=r*c)){ alert('Choose sensible custom values.'); return; }
    rows=r; cols=c; mines=m;
    seed = seedParam || Math.floor(Math.random()*1e9).toString();
    rand = mulberry32(xmur3(seed)());
    newBoard(); highlightKB();
  };

  document.getElementById('newGame').onclick = ()=>{
    const custom = seedInput.value.trim();
    if(custom){
      url.searchParams.set('seed', custom);
      location.href = url.toString();
      return;
    }
    seed = Math.floor(Math.random()*1e9).toString();
    rand = mulberry32(xmur3(seed)());
    newBoard(); highlightKB();
  };
  document.getElementById('restart').onclick = ()=>{ rand = mulberry32(xmur3(seed)()); newBoard(); highlightKB(); };

  // ---------- Boot ----------
  loadBests();
  if(seedParam){ seed = seedParam; rand = mulberry32(xmur3(seed)()); }
  newBoard(); highlightKB();
})();
</script>
</body>
</html>
